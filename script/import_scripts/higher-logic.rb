require File.expand_path(File.dirname(__FILE__) + "/base.rb")
#require 'htmlentities'
begin
  require 'tiny_tds' # https://github.com/jqr/php-serialize
rescue LoadError
  puts
  puts 'tiny_tds not found.'
  puts 'Add to Gemfile, like this: '
  puts
  puts "echo gem \\'tiny_tds\\' >> Gemfile"
  puts "IMPORT=1 bundle install"
  exit
end

class ImportScripts::HigherLogic < ImportScripts::Base
  BATCH_SIZE = 1000

  # CHANGE THESE BEFORE RUNNING THE IMPORTER

  DB_HOST ||= ENV['DB_HOST'] || "localhost"
  DB_NAME ||= ENV['DB_NAME'] || "hl"
  DB_PW ||= ENV['DB_PW'] || "hl"
  DB_PORT ||= ENV['DB_PORT'] || "1433"
  DB_USER ||= ENV['DB_USER'] || "sa"
  DB_AZURE ||= ENV['DB_AZURE'] == "FALSE"
  TABLE_PREFIX ||= ENV['TABLE_PREFIX'] || "dbo."
  RANDOM_CATEGORY_COLOR = ENV['RANDOM_CATEGORY_COLOR'] != "FALSE"
  ATTACHMENT_DIR ||= ENV['ATTACHMENT_DIR'] || '/path/to/attachments'
  IMPORT_AFTER ||= ENV['IMPORT_AFTER'] || "1970-01-01"
  CONVERT_HTML = true
  QUIET = true || ENV['VERBOSE'] == "FALSE"
  HOSTNAME = 'old.host.com'

  ATTACHMENTS_HEADER = '### Attachments'

  IGNORED_DISCUSSIONS = ['ignored', 'alsoignored'
                        ]

  puts "#{DB_USER}:#{DB_PW}@#{DB_HOST},#{DB_PORT} wants #{DB_NAME}. AZURE: #{DB_AZURE}" unless QUIET

  # Site settings (optional)
  #  SiteSetting.disable_emails = true
  SiteSetting.title = 'Higher Logic import'
  SiteSetting.allow_index_in_robots_txt = nil
  SiteSetting.login_required = true

  # Site settings required
  SiteSetting.tagging_enabled = true

  SiteSetting.max_attachment_size_kb = 102400
  SiteSetting.max_image_size_kb = 102400
  SiteSetting.max_username_length = 40

  def initialize

    if IMPORT_AFTER > "1970-01-01"
      print_warning("Importing data after #{IMPORT_AFTER}")
    end

    max_file_size_kb = 100000000
    # temporarily disable validation since we want to import all existing images and attachments
    SiteSetting.type_supervisor.load_setting(:max_image_size_kb, max: max_file_size_kb)
    SiteSetting.type_supervisor.load_setting(:max_attachment_size_kb, max: max_file_size_kb)

    # Tell MsSQL that you really want all of the results
    tds_query('SET TEXTSIZE 2147483647;')

    #     # Define custom fields
    #     @company_name_field = UserField.find_by_name("CompanyName")
    #     unless @company_name_field
    #       @company_name_field = UserField.create(name: "Company Name", description: "Where do you work?", field_type: "text", editable: true, required: false, show_on_profile: true, show_on_user_card: true)
    #     end
    #     unless @company_title_field
    #       @company_title_field = UserField.create(name: "Company Title", description: "What is your title?", field_type: "text", editable: true, required: false, show_on_profile: true, show_on_user_card: true)
    #     end
    #     unless @designation_field
    #       @designation_field = UserField.create(name: "Designation", description: "What is your designation?", field_type: "
    # text", editable: true, required: false, show_on_profile: true, show_on_user_card: true)
    #     end

    super
    @htmlentities = HTMLEntities.new
  end

  def execute
    import_users
    custom_create_categories
    import_categories
    import_library_categories
    import_library_entries
    map_cat_to_tags
    import_topics_and_posts

    import_groups
    import_group_members
    import_community_groups
    import_community_group_members
    create_custom_groups
    protect_categories
    deactivate_all_users
    update_tl0
    empower_full_users
  end

  def import_users
    puts '', "creating users"

    results = tds_query("SELECT count(*) count
                  FROM dbo.Contact C;")

    total_count = results.first['count']

    batches(BATCH_SIZE) do |offset|
      query = %{

      SELECT C.ContactKey AS id,
          concat(FirstName, ' ', LastName) AS name,
          EmailAddress AS email,
          UserStatus AS active,
          HLAdminFlag AS admin,
          DisplayName AS username,
          CreatedOn AS created_at,
          Bio as bio,
          CompanyName,
          CompanyTitle,
          Designation,
          WebsiteUrl as website,
          ProfileImage AS avatar,
          FileTypeCode AS file_type,
          Birthday AS date_of_birth
          FROM dbo.contact as C
          WHERE EmailAddress is not NULL
          ORDER BY CreatedOn
          OFFSET #{offset} ROWS
          FETCH NEXT #{BATCH_SIZE} ROWS ONLY ;
      }

      results = tds_query(query).collect
      break if results.count < 1

      #      next if all_records_exist? :users, results.map { |u| u['id'].to_s }

      create_users(results, total: total_count, offset: offset) do |user|
        # make bogus email so email gets generated by create_user?
        email = user["email"].presence
        {
          id: user['id'].to_s,
          email: email,
          username: user['username'],
          name: user['name'].presence ? user['name'].gsub(/^ +/, '') : nil,
          created_at: user['created_ad'] == nil ? 0 : Time.zone.at(user['created_at']),
          bio_raw: user['bio'],
          website: user['website'],
          last_seen_at: user['last_seen_at'] == nil ? 0 : Time.zone.at(user['last_seen_at']),
          admin: user['admin'] == 1,
          post_create_action: proc do |newuser|
            if user['avatar'].presence && user['file_type'] == 'JPG'
              begin
                upload = upload_file_from_data(user['avatar'], user['file_type'])
                if upload.persisted?
                  newuser.import_mode = false
                  newuser.create_user_avatar
                  newuser.import_mode = true
                  newuser.user_avatar.update(custom_upload_id: upload.id)
                  newuser.update(uploaded_avatar_id: upload.id)
                else
                  puts "Error: Upload did not persist for #{user['id']}!"
                end
              rescue SystemCallError => err
                puts "Could not import avatar #{err.message}"
              end
            end
            if user['active'] == 'Disabled'
              newuser.suspended_at = Time.zone.at(Time.now)
              newuser.suspended_till = 200.years.from_now
              newuser.active = false
              newuser.save!
            end
            if newuser.save
              StaffActionLogger.new(Discourse.system_user).log_user_suspend(newuser, 'Disabled at import')
            else
              Rails.logger.error("Failed to suspend user #{user.username}. #{user.errors.try(:full_messages).try(:inspect)}")
            end
            # if user["CompanyName"]
            #   newuser.custom_fields.merge!("user_field_#{@company_name_field.id}" => user["CompanyName"])
            # end
            # if user["CompanyTitle"]
            #   newuser.custom_fields.merge!("user_field_#{@company_title_field.id}" => user["CompanyTitle"])
            # end
            # if user["Designation"]
            #   newuser.custom_fields.merge!("user_field_#{@designation_field.id}" => user["Designation"])
            # end
            # newuser.save!
          end
        }
      end
    end
  end

  def invalid_email
    SecureRandom.hex
  end

  def import_discussion_categories
    puts "", "importing discussion categories..."

    categories = tds_query("
                              SELECT DISTINCT DiscussionCategoryName as name
                              MIN(DiscussionKey) as ID
                              FROM Discussion
                            ").collect

    puts "found #{categories.count} discussion categories..."
    create_categories(categories) do |category|
      {
        id: category['id'].to_s + category['name'],
        name: category['name'],
        color: RANDOM_CATEGORY_COLOR ? (0..2).map { "%0x" % (rand * 0x80) }.join : nil
      }
    end
  end

  def import_categories
    puts "", "importing categories..."

    categories = tds_query("
                              SELECT DiscussionName as name,
                              DiscussionCategoryName as category,
                              DiscussionKey as id
                              FROM dbo.Discussion
                            ").collect

    puts "found #{categories.count} categories..."
    create_categories(categories) do |category|
      puts "Adding cat ID #{category['id']}"
      if IGNORED_DISCUSSIONS.include?(category['name'])
        puts "Skipping #{category['name']}"
        next
      end
      puts "Creating #{category['name']}"
      parent = category_id_from_imported_category_id(category['id'].to_s + category['name'])
      {
        id: category['id'],
        name: category['name'],
        parent_category_id: parent,
        color: RANDOM_CATEGORY_COLOR ? (0..2).map { "%0x" % (rand * 0x80) }.join : nil
      }
    end
  end

  def import_library_categories
    puts "", "importing library categories..."

    parent = category_id_from_imported_category_id('IMPORTEDLIBRARIES')
    puts "Found parent #{parent}!"

    categories = tds_query("
                              SELECT
                              LibraryKey as id,
                              LibraryName as name,
                              LibraryDescription as description
                              FROM dbo.Library
                            ").collect

    puts "", "found #{categories.count} categories..."
    categories.each do |category|
      cat_id = @lookup.category_id_from_imported_category_id('IMPORTEDLIBRARIES')
      cat = Category.find(cat_id)
      add_category(category['id'], cat)
    end
  end

  def import_library_entries
    puts "", "importing library file entries..."

    entry_count = tds_query("SELECT COUNT(LibraryKey) count FROM dbo.LibraryEntry").first["count"]

    batches(BATCH_SIZE) do |offset|
      entries = tds_query(<<-SQL
          SELECT DocumentFileKey DocumentFileKey, LE.LibraryKey LibraryKey, LE.ContactKey author, LE.DocumentTypeName DocType,
               Y.YouTubeURL youtube,
               F.CreatedOn created_at,
               F.OriginalFileName original_name,
               LE.EntryDescription raw,
               LE.EntryTitle title
               FROM dbo.LibraryEntry LE
               LEFT JOIN dbo.LibraryEntryYouTube Y
               ON LE.DocumentKey=Y.DocumentKey
               LEFT JOIN dbo.LibraryEntryFile F
               ON LE.DocumentKey=F.DocumentKey
               WHERE LE.DocumentTypeName != 'Egroup Attachment'
               AND LE.DocumentTypeName != 'Hyperlink'
               ORDER BY LibraryKey
               OFFSET #{offset} ROWS
               FETCH NEXT #{BATCH_SIZE} ROWS ONLY ;
      SQL
      ).collect

      break if entries.count < 1
      create_posts(entries, total: entry_count, offset: offset) do  |entry|
        user_id = user_id_from_imported_user_id(entry["author"]) || Discourse::SYSTEM_USER_ID
        raw = process_post(entry['raw'] || "")
        # handle link or upload
        if entry['DocType'] == 'YouTube Video'
          raw = "\n\n#{entry['youtube']}\n\n#{raw}"
        end
        # hyperlnks not imported
        if entry['DocType'] == 'Hyperlink'
          # never reached
        end
        if entry['DocType'] == 'Standard File Upload'
          original_name = entry['original_name'] || "NO FILENAME GIVEN"
          filename = File.join(ATTACHMENT_DIR, original_name)
          if File.exists?(filename)
            upload = create_upload(user_id, filename, original_name || filename)

            if upload.nil? || !upload.valid?
              raw += "Upload not valid :(  #{filename}"
              puts upload.errors.inspect if upload
            else
              raw = html_for_upload(upload, original_name) + raw
            end
          else
            puts "Attachment file doesn't exist: #{original_name}"
          end
        end
        document_key = "document-#{entry["DocumentFileKey"]}"
        {
          id: document_key,
          user_id: user_id,
          title: entry['title'],
          category: category_id_from_imported_category_id(entry["LibraryKey"]),
          raw: raw,
          created_at: entry["created_at"]
        }
      end
    end
  end

  def import_library_file_entries
    puts "", "importing library file entries..."

    files = tds_query("SELECT
                              DocumentFileKey,
                              DocumentKey,
                              ContactKey,
                              FileDescription,
                              OriginalFileName
                              FROM LibraryEntryFile
                              LibraryDescription as description,
                              FROM dbo.Lilbrary
                            ").collect

  end

  def import_topics_and_posts
    puts "", "creating topics and posts"

    total_count = tds_query("SELECT count(*) count from dbo.DiscussionPost").first["count"]

    puts "Found #{total_count} posts"

    topic_first_post_id = {}

    batches(BATCH_SIZE) do |offset|
      results = tds_query("

        SELECT
        Body AS raw,
        CreatedOn AS created_at,
        Subject AS title,
        MessageID_ AS id,
        MessageKey,
        ParentID_ AS parent_id,
        MessageType AS type,
        AttachmentDocumentKey AS attachment_key,
        ContactKey AS user_id,
        DiscussionKey AS category_id
        FROM dbo.DiscussionPost
        ORDER BY created_at

        OFFSET #{offset} ROWS
        FETCH NEXT #{BATCH_SIZE} ROWS ONLY;
      ")

      break if results.count < 1

      next if all_records_exist? :posts, results.map { |t| t['id'] }

      create_posts(results, total: total_count, offset: offset) do |m|
        next if @lookup.post_id_from_imported_post_id(m['id'])
        skip = false
        mapped = {}

        mapped[:id] = m['id']
        mapped[:user_id] = user_id_from_imported_user_id(m['user_id'].to_s) || -1
        mapped[:raw] = process_post(m['raw'])
        mapped[:created_at] = Time.zone.at(m['created_at'])

        if m['type'] == 'New'
          category = category_id_from_imported_category_id(m['category_id'])
          mapped[:category] = category
          mapped[:title] = m['title']
          unless category
            puts "Skipping post with no category (#{m['category_id']}). #{m['title']} "
            skip = true
          end
        else
          parent = topic_lookup_from_imported_post_id(m['parent_id'])
          if parent
            mapped[:topic_id] = parent[:topic_id]
          else
            puts "Parent post doesn't exist. Skipping #{m["id"]}: #{m["title"][0..40]}" unless QUIET
            skip = true
          end
        end
        if m['attachment_key']
          mapped[:raw] += add_attachment_from_zip(m['attachment_key'], mapped[:user_id])
        end
        mapped[:post_create_action] = proc do |post|
          Permalink.create(url: "/MessageKey/#{m['MessageKey']}", post_id: post.id) rescue nil
          if @import_tags && post.post_number == 1
            if tag_names = @tag_map[m['category_id']]
              DiscourseTagging.tag_topic_by_names(post.topic, staff_guardian, tag_names)
            end
          end
        end

        skip ? nil : mapped
      end
    end
  end

  def staff_guardian
    @staff_guardian ||= Guardian.new(Discourse.system_user)
  end

  def process_post(raw)
    raw.gsub!(/(-+?)<br[ \/]*>Original Message:(.*)/m, "")
    raw.gsub!(/(-+?)Original Message(.*)/m, "")
    raw.gsub!(/<br ?\/?>/, "\n")
    # strip links to tags
    raw.gsub!(/<a data-tag-text.+?<\/a>/i, "")
    raw.gsub!(/<table id=\"mce.*<\/table>/m, "")
    raw.gsub!(/<\/p>------------------------------\n.*/m, "")
    raw.gsub!(/<\/?p>/, "\n")
    raw.gsub!(/------------------------------(.*)------------------------------/m, "")
    # convert @mentions
    raw.gsub!(/<a class="user-content-mention".+?data-contactkey="([-a-fA-F0-9]+?)".+?>.+<\/a>/) {
      | id |
      import_id = Regexp.last_match[1]
      uid = user_id_from_imported_user_id(import_id.upcase)
      if uid
        user = User.find(uid)
        if user
          "@#{user.username}"
        else
          "(Missing User? This shouldn't happen)"
        end
      else
        "User #{import_id} not found"
      end
    }
    # fix links to Messages
    raw.gsub!(/https?:\/\/#{HOSTNAME}\/.*?MessageKey=([-a-fA-F0-9]+?)&[-;=&a-zA-Z0-9#]*/) { | id |
      message_key = Regexp.last_match[1].upcase
      if mid = Regexp.last_match[0].match(/.*#bm(.+)/)
        post_num = mid[1].length < 5 ? "/#{(mid[1].to_i + 1)}" : ""
      end
      permalink = Permalink.find_by_url("MessageKey/#{message_key}")
      if !permalink
        "/t/link-to-message-not-imported"
      else
        post = Post.find(permalink.post_id)
        topic = Topic.find(post.topic_id)
        "/t/#{topic.id}#{post_num}"
      end
    }

    # ignore library documents
    raw.gsub!(/https?:\/\/#{HOSTNAME}\/.*?DocumentFileKey=([-a-fA-F0-9]+?)[&]*[-;=&#a-zA-Z0-9]*/) { | id |
      document_file_key = Regexp.last_match[1].upcase
      topic_id = topic_lookup_from_imported_post_id("document-" + document_file_key)
        "/t/#{topic_id}"
    }

    # fix links to Communities -- WORKS!
    raw.gsub!(/https?:\/\/#{HOSTNAME}\/.*?\?CommunityKey=([-a-fA-F0-9]+)[-;=&#a-zA-Z0-9]*/) { | id |
      community_key = Regexp.last_match[1].upcase
      puts "Found CommunityKey #{community_key}" unless QUIET
      query = "SELECT DiscussionKey, CommunityName from Community WHERE CommunityKey='#{community_key}';"
      result = tds_query(query).collect
      if result.count < 1
        "(Cannot find this community: #{community_key})"
      else
        id = result.first['DiscussionKey']
        category_id = category_id_from_imported_category_id(id)
        community_name = result.first['CommunityName']
        if !category_id
          "(This was a link to the old #{id} community: #{community_key})"
        else
          category = Category.find(category_id)
          puts "Found a community link! [#{category.name}](/c/#{category.slug})" unless QUIET
          "[#{category.name}](/c/#{category.slug})"
        end
      end
    }
    # TODO fix links to Library Documents

    raw
  end

  def import_groups
    puts "", "Importing groups . . ."

    groups = tds_query("SELECT SecurityGroupKey AS id,
                        SecurityGroupName as name,
                        SecurityGroupDescription as description
                        FROM dbo.SecurityGroup
                        WHERE type = 'Custom'
                       ")

    create_groups groups.each do |group|
      description = group['description']
      {
        name: group['name'],
        id: group['id'],
        full_name: group['description'] || group['name'],
      }
    end
  end

  def import_group_members
    puts "", "importing group members..."

    group_members = tds_query("SELECT
                               ContactKey AS user_id,
                               SecurityGroupKey as group_id
                               FROM ContactSecurityGroup
                               WHERE GroupRole = 'Member'")

    group_members.each do |member|
      user_id = user_id_from_imported_user_id(member['user_id'])
        gid = group_id_from_imported_group_id(member['group_id'])
        if user_id && gid
          group = Group.find(gid)
          user = User.find(user_id)
          group.add(user)
        end
    end
  end

  ##################################################
  def import_community_groups
    puts "", "Importing community groups . . ."

    groups = tds_query("SELECT CommunityKey AS id,
                        CommunityName as name,
                        Description as description
                        FROM dbo.Community
                       ")

    create_groups groups.each do |group|
      description = group['description']
      {
        name: group['name'] + " Community",
        id: group['id'],
        full_name: group['description'] || group['name'],
      }
    end
  end

  def import_community_group_members
    puts "", "importing community members..."

    group_members = tds_query("SELECT
                               ContactKey AS user_id,
                               CommunityKey as group_id
                               FROM CommunityMember
                               ")

    group_members.each do |member|
      user_id = user_id_from_imported_user_id(member['user_id'])
        gid = group_id_from_imported_group_id(member['group_id'])
        if user_id && gid
          group = Group.find(gid)
          user = User.find(user_id)
          group.add(user)
        end
    end
  end

  ##################################################

  def upload_file_from_data(data, file_type, original_name = nil)
    #puts "Uploading #{file_type} #{original_name}"
    if data.length < 1
      return nil
    end
    if original_name.presence
      original_name.gsub!(/[\x00\/\\:\*\?\"<>\|\'\(\)]/, '_')
      file = Tempfile.new(['upload', original_name])
    else
      if file_type == 'image/Jpeg'
        ext = '.jpg'
      else
        ext = '.bin'
      end
      file = Tempfile.new(['avatar', ext])
    end
    file.binmode
    file.write(data)
    file.close

    if File.exists?(file.path)
      upload = create_upload(Discourse::SYSTEM_USER_ID, file.path, original_name || file.path)

      if upload.nil? || !upload.valid?
        puts "Upload not valid :(  #{file.path}"
        puts upload.errors.inspect if upload
        return nil
      end
    else
      puts "Attachment file doesn't exist: #{file.path}"
    end
    file.unlink

    upload
  end

  def add_attachment_from_zip(zip, user_id)
    html = insert = ""
    zip_file = "#{ATTACHMENT_DIR}/#{zip.downcase}.zip"
    if !File.exist?(zip_file)
      puts "Can't find zip file: #{zip_file}. Skipping." unless QUIET
      html = "\n\n### Attachment Missing. \nCan't find zip file: #{zip_file}. Perhaps ask me to upload it again?.\n\n"
    else
      Zip::File.open(zip_file).each do |entry|
        upload = create_upload(user_id, "#{ATTACHMENT_DIR}/#{entry.name}", entry.name)
        if upload.nil? || !upload.valid? || !upload.original_filename.presence
          puts "Upload not valid (#{entry.name} from #{zip})" unless QUIET
          puts upload.errors.inspect if upload
          insert = "\nUpload failed for #{entry.name} from #{zip} because #{upload.errors.inspect}. Perhaps ask me to upload it again?"
        else
          insert = "\n" + html_for_upload(upload, entry.name)
        end
      end
      html = insert.length == 0 ? "" : "\n\n#{ATTACHMENTS_HEADER}\n#{insert}"
    end
    html
  end

  def tds_query(sql)
    puts "tds_query:#{sql}" unless QUIET
    if !@client.presence
      begin
        @client = TinyTds::Client.new(
          host: DB_HOST,
          username: DB_USER,
          password: DB_PW,
          database: DB_NAME,
          port: DB_PORT,
          azure: DB_AZURE
        )
      #      puts "TDS: Opened New connection"
      rescue Exception => e
        puts '=' * 50
        puts e.message
        puts <<EOM
Cannot log in to database.

Hostname: #{DB_HOST}
Username: #{DB_USER}
Password: #{DB_PW}
database: #{DB_NAME}
port: #{DB_PORT}

You should set these variables:

export DB_HOST="localhost"
export DB_NAME="my-database"
export DB_PW="password"
export DB_PORT="1433"
export DB_USER="cs"
export DB_AZURE="false"
export IMPORT_AFTER="1970-01-01"
export TABLE_PREFIX="dbo.cs_"
export ASPNET_TABLE_PREFIX="dbo.aspnet_"
export RANDOM_CATEGORY_COLOR="TRUE"

Exiting.
EOM
        exit
      end
    end
    @result.cancel unless !@result.presence
    begin
      # puts "tds_query: Query #{sql}"
      @result = @client.execute(sql)
      @result.each
      # puts "tds_query: Got #{@result.affected_rows} or #{@result.count}."
    rescue Exception => e
      puts "tiny_tds: ERROR --  #{e}"
      exit
    end
    @result
  end

  def deactivate_all_users
    User.where("id > 0 and admin != true").update_all(active: false)
  end

  def print_warning(message)
    $stderr.puts "#{message}"
  end

  def custom_create_categories
    puts "", "Creating custom categories"
    categories = [
      {
        id: 'import_id',
        name: 'Category Name',
        description: 'Category Name Description'
      }
    ]

    create_categories(categories) do |category|
      puts "Creating #{category[:name]}"
      {
        id: category[:id],
        name: category[:name],
        description: category[:description],
        color: RANDOM_CATEGORY_COLOR ? (0..2).map { "%0x" % (rand * 0x80) }.join : nil
      }
    end
    # g = Group.find(group_id)
    # cat = Category.find(category_id)
    # everyone = Group::AUTO_GROUPS[:everyone]
    # permissions = {}
    # permissions[group_id] = CategoryGroup.permission_types[:full]
    # permissions[everyone] = CategoryGroup.permission_types[:readonly]
    # cat.permissions= permissions
    # cat.save

  end

  def create_custom_groups
    puts "", "Importing custom groups . . ."
    groups = [
      {
        name: 'GroupName',
        id: 'GroupName',
        public: false,
        full_name: 'Pretty Name',
        allow_membership_requests: false
      }
    ]
    create_groups groups.each do |group|
      {
        name: group[:name],
        id: group[:id],
        full_name: group[:full_name],
        bio_raw: group[:description],
        allow_membership_requests: group[:allow_membership_requests]
      }
    end
  end

  def empower_full_users
    puts "", "Embpowering full users"
    group_id = Group.where("name = 'Full_Member'").first.id
    members = GroupUser.where("group_id = #{group_id}")
    members.each do |member|
      u = User.find(member.user_id)
      u.trust_level = 2
      u.save
    end
    cat = Category.where("name = 'Members Lounge'").first
    permissions = {}
    permissions[group_id] = CategoryGroup.permission_types[:full]
    cat.set_permissions(permissions)
    cat.save
  end

  def make_group_members_tl2(group_name)
    group_id = Group.where("name = '#{group_name}'").first.id
    members = GroupUser.where("group_id = #{group_id}")
    members.each do |member|
      u = User.find(member.user_id)
      u.trust_level = 2
      u.save
    end
  end

  def limit_category_access_to_group(group_name, category_name)
    group_id = Group.where("name = 'Full_Member'").first.id
    cat = Category.where("name = '#{category_name}'").first
    if !cat
      puts "Can't find category #{category_name}"
      return nil
    end
    permissions = {}
    permissions[group_id] = CategoryGroup.permission_types[:full]
    cat.set_permissions(permissions)
    cat.save
  end

  def protect_categories
    #limit_category_access_to_group('Group Name', 'Category Name')
    #make_group_members_tl2('Group_Name')
  end

  def map_cat_to_tags
    SiteSetting.tagging_enabled = true
    SiteSetting.max_tags_per_topic = 10
    @import_tags = true
    @tag_map = {}
    #@tag_map['IMPORT_ID'] = ['tag1,tag2']
    @tag_map['0613895A-A485-4F5D-9F75-228BD0D0216A'] = ['category_slug']
  end

end

ImportScripts::HigherLogic.new.perform
